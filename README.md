## 📝 프로젝트 소개
이 프로젝트는 사용자들이 회원 가입 및 로그인 후 다양한 상품을 조회하고 주문할 수 있는 서비스를 제공하는 플랫폼입니다. 
MSA(Microservices Architecture)를 이용해 구축되었으며, 분산 시스템의 특성을 활용하여 확장성과 안정성을 확보하고자 했습니다.

---

### ✅ 요구사항 및 필수기능
- **API 제공**  
  상품 추가, 상품 목록 조회, 주문 추가, 주문 상품 추가, 주문 단건 조회, 로그인, 회원가입
- **Gateway 인증 처리**  
  Gateway 서비스의 필터 로직을 수정해 JWT 토큰을 검증하는 로직을 구현하고 인증 처리
- **로드밸런싱 설정**  
  상품 서비스는 70%와 30%의 가중치로 요청이 전달되도록 구성
- **서비스 연동 및 모니터링**  
  Zipkin을 통해 주문과 상품 서비스를 연동하고 Duration을 측정
- **캐싱 적용**  
  주문 조회 결과를 60초 동안 캐싱하며, 새로운 상품 추가 시 캐시 갱신
- **환경 분리**  
  로컬과 운영 환경을 분리하고 운영 환경은 RDS 주소로 접근하도록 설정
- **Fallback 처리**  
  API 호출 실패 시 대체 로직을 통해 오류 관리

---

### 🛠️ 기술스택
- **프레임워크 및 언어**
  - Spring Boot 3.3.7
  - Java 17
  - Gradle
- **MSA 및 분산 시스템**
  - Eureka: 서비스 레지스트리 및 디스커버리
  - Spring Cloud Gateway: API Gateway로 마이크로서비스 간 트래픽 관리
  - FeignClient: 서비스 간 통신을 위한 클라이언트 구현
  - Resilience4j: 서킷 브레이커를 통해 장애 회복성 확보
  - Redis: 데이터 캐싱
  - Zipkin: 분산 추적 및 모니터링
  - Micrometer, Brave: 트레이싱 및 메트릭 수집
- **보안**
  - JWT 기반 인증
  - Spring Security
- **데이터 관리**
  - Spring Data JPA
  - Redis

---

## 🔍 기술 질문
1. 고객 주문 시 상품 서비스에서 재고를 차감했으나 주문 서비스에서 에러가 발생하면 어떻게 해결할 수 있을까요?
   - 서킷 브레이커를 통해 통신 실패를 감지하고, 대체 로직을 적용해 추가적인 오류를 관리해야 합니다.
2. 마이크로서비스 간 통신 보안은 어떻게 보장할 수 있을까요?
   - Gateway 를 통해 서비스 간 API 노출을 줄이고, 인증 및 인가를 중앙에서 수행합니다. 
   - 또한 VPC 내부에서만 서비스 간 통신을 허용하여 보안을 강화합니다.
3. MSA 환경에서 발생할 수 있는 의존성 순환 문제를 어떻게 해결할 수 있을까요?
   - 이벤트 브로커를 통해 직접적인 호출 대신 이벤트 기반 통신을 도입하는 방법이 있습니다.
4. 분산 시스템에서의 데이터 일관성을 어떻게 유지하나요?
   - Saga 패턴을 이용해 로컬 트랜잭션을 순차적으로 전체 프로세스로 반영하거나, 이벤트 생성으로 데이터 일관성을 유지하는 방법을 사용합니다.
5. 레거시 모놀리식 서비스를 MSA 로 전환해야하는 이유가 무엇이 있나요?
   - 서버 스케일 아웃 시에도 로드 밸런싱을 통해 안정성을 높이며, 문제가 발생할 경우 대체 서버로 요청을 처리합니다. 다만 장단점이 명확하게 있어 상황에 맞는 적절한 판단이 필요합니다.